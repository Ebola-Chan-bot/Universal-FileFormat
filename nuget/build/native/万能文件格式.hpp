#pragma once
#ifdef __cpp_lib_modules
import std;
#else
#include<iostream>
#endif
#ifdef _WIN32
#include<Windows.h>
#endif
namespace 万能文件格式
{
	//尝试使用无效值作为句柄将导致未定义行为
	constexpr uint64_t 无效值 = -1;
	struct _文件头;
	//此类为抽象基类，必须由派生类负责分配基础内存资源。指针分配器可以取得指向内存块的裸指针，以支持丰富的C++原生操作。派生类完成构造后还必须调用初始化方法。
	struct 指针分配器
	{
		//指示文件中现有内容是否应当被忽略，创建新的空文件。构造完成后必须先调用此方法才能使用任何其它功能，否则导致未定义行为。可以由派生类的构造方法负责调用，也可以要求用户手动调用，此方法本身将会调用分配空间方法。如果试图打开而非新建一个无效的文件，将抛出std::domain_error。
		void 初始化(bool 新建);
		//分配一个空闲句柄，具有指定的空间。
		uint64_t 分配(uint64_t 字节数);
		//为指定句柄分配空间。如果句柄已经有空间，将会保留原有数据，除非新空间比原空间小，将导致数据被截断。如果新空间更大，在保留原有数据的同时，多余的空间将填充未定义的数据。避免使用不必要的过大句柄值，将导致空间浪费。
		void 分配(uint64_t 句柄, uint64_t 字节数);
		//取得指定句柄的裸指针。该指针仅临时有效，对分配器的任何更改都会导致指针失效。指定无效句柄将返回nullptr。
		void* 取指针(uint64_t 句柄);
		//取得指定句柄的块大小。如果句柄无效，将返回无效值。
		uint64_t 块大小(uint64_t 句柄)const noexcept;
		//释放指定句柄，被释放的空间可以重新参与分配。空间中包含的非平凡对象不会被自动析构，用户应当在释放前先清理它们。重复释放无效的句柄将不做任何事。
		void 释放(uint64_t 句柄)const noexcept;
		//此值由派生类在分配空间时设置，一般不应直接修改
		_文件头* _文件头指针;
		//派生类应当实现此方法，分配指定字节数的空间，并设置文件头指针。实际分配的空间可以不等于，但不应小于请求的字节数，否则应当抛出异常。字节数的意义是从文件头开始的全部连续空间，而不是新增的空间，因此新空间中应包含文件中原有的数据。即使指定的字节数小于文件的真实大小，也不代表剩余部分的数据是可丢弃的。
		virtual void 分配空间(uint64_t 字节数) = 0;
		virtual ~指针分配器() {}
	};
#ifdef _WIN32
	enum class 文件选项
	{
		//只读方式打开文件，不允许写出。文件必须存在，否则导致未定义行为。
		只读,
		//读写方式打开文件。如果文件不存在，将创建。
		读写,
		//覆盖创建新文件，无论文件是否存在。
		覆盖
	};
	//Windows上的一种常用的指针分配器实现，使用内存映射文件来操作磁盘上的文件。
	struct 文件分配器:指针分配器
	{
		//使用 Win32 API CreateFile 以从路径获取文件句柄。此对象使用期间，文件句柄必须保持有效。构造可能会失败，抛出std::system_error。以非覆盖选项打开无效文件将抛出std::domain_error。无效的文件选项将抛出std::invalid_argument。
		文件分配器(HANDLE 文件句柄, 文件选项 选项 = 文件选项::读写);
		//文件句柄的生命周期由用户负责管理，此对象的析构不会关闭文件句柄。正确析构也不依赖文件句柄，用户可以先关闭文件句柄再析构此对象。
		~文件分配器();
		const HANDLE 文件句柄;
		//如果文件以只读方式打开，初始化、分配、释放，以及对取得的指针进行写出都会导致Win32内存映射文件API实现定义的行为。
		const bool 只读;
		//此对象绑定内存映射文件的生命周期，因此禁止拷贝
		文件分配器(const 文件分配器&) = delete;
		//此对象绑定内存映射文件的生命周期，因此禁止拷贝
		文件分配器& operator=(const 文件分配器&) = delete;
		void 分配空间(uint64_t 字节数) override;
	protected:
		HANDLE _映射句柄;
	};
#endif
	//有些基础资源不支持分配裸指针，只允许流式操作。流式分配器只需要提供一个标准IO流，采用与流式资源兼容的操作，因此读写都需要提供缓冲区。
	struct 流式分配器
	{
		std::iostream& 基础流;
		//如果基础流支持写出，则必须支持随机访问和超范围的写出并扩展操作。此对象使用期间，基础流必须保持有效。如果流不支持写出，初始化、分配、写出和释放将导致基础流实现定义的行为。还需要指一个bool指示是否无视流中原有内容新建文件，若为false则会先尝试识别文件头。
		流式分配器(std::iostream& 基础流, bool 新建);
		//分配一个空闲句柄，具有指定的空间
		uint64_t 分配(uint64_t 字节数);
		//为指定句柄分配空间。如果句柄已经有空间，将会保留原有数据，除非新空间比原空间小，将导致数据被截断。如果新空间更大，在保留原有数据的同时，多余的空间将填充未定义的数据。避免使用不必要的过大句柄值，将导致空间浪费。
		void 分配(uint64_t 句柄, uint64_t 字节数);
		//取得指定句柄的块大小。如果句柄无效，将返回无效值。
		uint64_t 块大小(uint64_t 句柄);
		//将缓冲区中的数据写出到句柄所指内存块。数据超出块的范围或无效句柄将导致未定义行为。
		void 写出(uint64_t 句柄, const void* 数据, uint64_t 字节数, uint64_t 块内偏移 = 0);
		//将句柄所指内存块的数据读入缓冲区。读入超出块范围或无效句柄的数据将导致未定义行为。
		void 读入(uint64_t 句柄, void* 数据, uint64_t 字节数, uint64_t 块内偏移 = 0);
		//释放指定句柄，被释放的空间可以重新参与分配。空间中包含的非平凡对象不会被自动析构，用户应当在释放前先清理它们。重复释放无效的句柄将不做任何事。
		void 释放(uint64_t 句柄);
	};
}